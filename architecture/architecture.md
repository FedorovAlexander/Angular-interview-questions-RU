## <a name="ngrx-store"></a>Приведите хороший пример когда нужно использовать ngrx/store?

- Когда в приложении мы имеем 5 или 10 уровней дерева компонентов. Мы передаем переменные через `@Input` и конечный компоненты знают, что нужно делать переданными данными. Но для промежуточных компонентов эти данные кажутся лишними. Компоненты становится сложнее переиспользовать. В случае нескольких уровней вложенности компонентов реагировать на события также становится проблемой. Все это усложняет масштабирование приложения.
  <br/>
- Когда данные могут изменятся как на клиенте так и на сервере. Store в таком случае будет являться единственным источником истины.

## <a name="race-condition"></a>Что такое "race condition" и какие баги могут быть связаны с этим? Как с ними справиться?

Состояние гонки возникает, когда два или более потоков могут получить доступ к общим данным, и они пытаются изменить их одновременно.

Пример. У нас есть список фильмов. По клику на название показывается описание фильма. Мы кликаем на "Форест Гамп", а потом сразу на "Интерстеллар". В идеальном мире ответы от сервера приходят по очереди. Но если описание к "Интерстеллар" придет первым, то мы получим баг.

Решить эту проблему можно с помощью `Subject` и `switchMap`. Вместо того, чтобы при каждом клике создавать новый независимый Observable мы создаем один Observable, который синхронизирует запросы. Оператор `switchMap` подписывается только на последний запрос. Если происходит новый запрос, он подписывается на него и отписывается от предыдущего.
<br/>
<br/>
<br/>
<br/>

<hr/>

Источники:<br/>

1. [https://blog.angular-university.io/angular-2-redux-ngrx-rxjs/](https://blog.angular-university.io/angular-2-redux-ngrx-rxjs/)
2. [https://blog.nrwl.io/rxjs-advanced-techniques-testing-race-conditions-using-rxjs-marbles-53e7e789fba5](https://blog.nrwl.io/rxjs-advanced-techniques-testing-race-conditions-using-rxjs-marbles-53e7e789fba5)
